#!/usr/local/bin/bpftrace

#include <net/sock.h>
#include <net/inet_connection_sock.h>
#include <linux/win_minmax.h>
#include <net/tcp.h>

kprobe:bbr_update_model
{
	$sk = (struct sock *)arg0;
	$rs = (struct rate_sample *)arg1;
	$port = $sk->__sk_common.skc_num;

	printf("%lld bbr_update_model() 0x%llx %ld %ld %d   %d\n",
		   nsecs,
		   arg0, $rs->delivered, $rs->interval_us, $rs->is_app_limited, $port);
}

kprobe:tcp_rack_detect_loss
{
	$sk = (struct sock *)arg0;
	$inet_csk = (struct inet_connection_sock *)$sk;
	$tp = (struct tcp_sock *)$sk;
	
	$minmax = $tp->rtt_min;
	$f_tcp_min_rtt = $minmax.s[0].v >> 2;
	$f_srtt_us = $tp->srtt_us >> 3;
	//$no_reo_wnd = $tp->sacked_out - $tp->reordering;

	printf("%lld tcp_rack_detect_loss() enter 0x%llx %d %d %d   %d %d %d\n",
		   nsecs,
		   $sk, $tp->reord_seen, $inet_csk->icsk_ca_state, $tp->sacked_out,
		   $tp->reordering, $f_tcp_min_rtt * $tp->rack.reo_wnd_steps, $f_srtt_us);
}

kretprobe:tcp_rack_detect_loss
{
	printf("%lld tcp_rack_detect_loss() exit\n",
		   nsecs);
}

kprobe:tcp_mark_skb_lost
{
	$sk = (struct sock *)arg0;
	$inet_csk = (struct inet_connection_sock *)$sk;
	$tp = (struct tcp_sock *)$sk;

	$port = $sk->__sk_common.skc_num;
	$skb = (struct sk_buff *)arg1;
	$cb = (struct tcp_skb_cb *)$skb->cb;
	$gso_segs = $cb->tcp_gso_segs;

	$minmax = $tp->rtt_min;
	$f_tcp_min_rtt = $minmax.s[0].v >> 2;
	$f_srtt_us = $tp->srtt_us >> 3;

	$tolerance = $tp->rack.rtt_us + $f_tcp_min_rtt * $tp->rack.reo_wnd_steps;
	$diff = $tp->tcp_mstamp - ($skb->skb_mstamp_ns / 1000);

	$len = $skb->len;
	
	printf("%lld tcp_mark_skb_lost() 0x%llx 0x%llx %d %d   %d %d %d %d   %d %d\n",
		   nsecs,
		   $sk, $skb, $port, $gso_segs,
		   $tolerance, $diff, $tp->rack.dsack_seen, $len,
		   $tp->rack.rtt_us, $f_srtt_us);
}

kprobe:tcp_check_dsack
{
	$sk = (struct sock *)arg0;
	$sp = (struct tcp_sack_block_wire *)arg2;
	$start_seq = $sp[0].start_seq;
	$end_seq = $sp[0].end_seq;

	// For unknown reasons, arg0 cannot be replaced with $sk
	printf("%lld tcp_check_dsack() 0x%llx 0x%x 0x%x\n",
		   nsecs,
		   arg0, $start_seq, $end_seq);
}

kretprobe:tcp_check_dsack
/retval/
{
	printf("%lld tcp_check_dsack() returns true\n",
		   nsecs);
}

kprobe:tcp_retransmit_skb
{
	$sk = (struct sock *)arg0;
	$skb = (struct sk_buff *)arg1;
	$segs = arg2;
	$cb = (struct tcp_skb_cb *)$skb->cb;
	$tcp_gso_segs = $cb->tcp_gso_segs;
	$tcp_gso_size = $cb->tcp_gso_size;

	// For unknown reashs, $cb->seq's LSB 2 bytes are corrupted
	// (by mss size, typically 1398 = 0x0576),
	// but $cb->end_seq works, so we derive $seq by $cb->end_seq - $len
	$end_seq = $cb->end_seq;
	$len = $skb->len;
	$seq = $end_seq - $len;

	printf("%lld tcp_retransmit_skb() 0x%llx 0x%llx 0x%x 0x%x   %d %d %d %d\n",
		   nsecs,
		   $sk, $skb, $seq, $end_seq,
		   $len, $segs, $tcp_gso_segs, $tcp_gso_size);
}

kretprobe:__tcp_retransmit_skb
/retval/
{
	printf("%lld __tcp_retransmit_skb() returns true\n",
		   nsecs);
}

kprobe:tcp_fastretrans_alert
{
	$sk = (struct sock *)arg0;
	$prior_snd_una = arg1;
	$num_dupack = arg2;
	printf("%lld tcp_fastretrans_alert() 0x%llx %x %d\n",
		   nsecs,
		   $sk, $prior_snd_una, $num_dupack);
}